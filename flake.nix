{
  description = "inferno";

  nixConfig = {
    # These are required to build the project, otherwise GHC will be built from
    # source (this is not always possible using haskell.nix either), so it makes
    # sense to enable them directly in the flake
    extra-substituters = [
      "https://cache.iog.io"
      "https://inferno.cachix.org"
    ];
    extra-trusted-public-keys = [
      "hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ="
      "inferno.cachix.org-1:48GsOmEfRPXpTZsQSmnD2P42lpbUeHrjlzyhasL5rug="
    ];
    bash-prompt = "\\[\\e[0;37m\\](\\[\\e[0m\\]nix) \\[\\e[0;1;91m\\]inferno \\[\\e[0m\\]\\w \\[\\e[0;1m\\]Î» \\[\\e[0m\\]";
  };

  inputs = {
    nixpkgs.follows = "haskell-nix/nixpkgs-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    treefmt-nix.url = "github:numtide/treefmt-nix";
    # haskell.nix has far better support for multi-component projects, so it's
    # preferable over nixpkgs' Haskell support
    haskell-nix.url = "github:input-output-hk/haskell.nix";
    npm-buildpackage.url = "github:serokell/nix-npm-buildpackage";
    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };
  };

  outputs =
    { self
    , nixpkgs
    , flake-parts
    , treefmt-nix
    , haskell-nix
    , ...
    }@inputs:
    let
      inherit (nixpkgs) lib;

      defaultCompiler = "ghc924";

      # Takes an attribute set mapping compiler versions to `flake`s generated
      # by `haskell.nix` (see `flakesFor` above) and suffixes each derivation
      # in all flake outputs selected by `attr` with the corresponding compiler
      # version, then flattens the resulting structure to combine all derivations
      # into a single set
      #
      #    collectOutputs
      #      "checks"
      #      {
      #        ghc8107 = { checks = { x:y:z = <drv>; }; };
      #        ghc922 = { checks = { x:y:z = <drv>; }; };
      #      }
      #
      # => { x:y:z-ghc8107 = <drv>; x:y:z-ghc922 = <drv>; }
      collectOutputs = attr: flakes:
        let
          outputsByCompiler = lib.mapAttrsToList
            (compiler: flake: { "${compiler}" = flake.${attr} or { }; })
            flakes;
          addSuffix = compiler: lib.attrsets.mapAttrs'
            (output: drv:
              lib.attrsets.nameValuePair "${output}-${compiler}" drv
            );
          withSuffixes = builtins.map
            (builtins.mapAttrs addSuffix)
            outputsByCompiler;
          justOutputs = builtins.concatMap builtins.attrValues withSuffixes;
        in
        builtins.foldl' (x: y: x // y) { } justOutputs;

      # Everything related to the haskell.nix project needs to be defined here
      # in order to be used by both the system-enumerated outputs (`packages`,
      # `devShells`, etc, ...) and the non-enumerated ones (`overlays`, etc...).
      # This also means that everything needs to be parameterized by `pkgs`

      # Get the autogenerated flake outputs from `haskell.nix`, for different
      # GHC versions, with or without profiling enabled
      flakesFor = pkgs: {
        "${defaultCompiler}-prof" = (
          infernoFor {
            inherit pkgs;
            compiler = defaultCompiler;
            profiling = true;
            ghcOptions = [ "-eventlog" ];
          }
        ).flake { };
      }
      // builtins.listToAttrs
        (
          lib.lists.forEach
            (
              [ defaultCompiler ]
                # only GHC 8.10.7 or newer is supported on M1 Macs
                ++ lib.optional (pkgs.system != "aarch64-darwin") "ghc884"
            )
            (compiler:
              lib.attrsets.nameValuePair
                compiler
                # TODO
                # Do we want to enable any `crossPlatforms` here?
                ((infernoFor { inherit compiler pkgs; }).flake { })
            )
        );

      # This should be parameterized by the `pkgs` used to build the project. We
      # want users who get packages from our `overlays.default` to be able to
      # use their own `nixpkgs` without having to instantiate ours as well
      # (which would happen if we just use `self.packages` directly in the overlay)
      infernoFor = { compiler, pkgs, ghcOptions ? [ ], profiling ? false }:
        pkgs.haskell-nix.cabalProject {
          name = "inferno";
          compiler-nix-name = compiler;
          src = builtins.path {
            path = ./.;
            filter = path: _:
              builtins.any
                (ext: !lib.hasSuffix ext path)
                [ ".nix" ".md" ".yml" ];
          };
          shell = {
            withHoogle = true;
            tools = {
              cabal = { };
              # FIXME
              # See https://github.com/plow-technologies/inferno/issues/25
              #
              # # This is the final supported version for our current compilers
              # haskell-language-server = "1.8.0.0";
            };
            buildInputs = [ pkgs.nixpkgs-fmt ] ++
              # ormolu build currently segfaults on the M1
              lib.optional (pkgs.system != "aarch64-darwin") (ormoluFor compiler pkgs);
          };
          modules = [
            {
              enableLibraryProfiling = profiling;
              packages = {
                # This takes forever to build
                ghc.components.library.doHaddock = false;
              };
              packages.inferno-core = {
                enableLibraryProfiling = profiling;
                enableProfiling = profiling;
                inherit ghcOptions;
              };
            }
          ];
        };

      # Get the same version of `ormolu` everywhere, including the shell
      ormoluFor = compiler: pkgs: pkgs.haskell-nix.tool
        compiler "ormolu" "0.5.0.1";

      # Inferno's VSCode packages
      vsCodeInfernoFor = pkgs:
        let
          modules = vscode-inferno-syntax-highlighting.passthru.nodeModules;
          vscode-inferno-syntax-highlighting =
            pkgs.buildNpmPackage {
              src = ./vscode-inferno-syntax-highlighting;
              npmBuild = ''
                npm run build-tm
                ${modules}/node_modules/@vscode/vsce/vsce package
                npm run build-monarch
              '';
              installPhase = ''
                mkdir $out
                cp *.vsix $out
                cp syntaxes/inferno.monarch.json $out
              '';
            };
          vscode-inferno-lsp-server = pkgs.buildNpmPackage {
            src = ./vscode-inferno-lsp-server;
            nativeBuildInputs = [ pkgs.nodePackages.typescript ];
            npmBuild = ''
              npm run package
            '';
            installPhase = "mkdir $out && cp *.vsix $out";
          };
        in
        {
          inherit
            vscode-inferno-syntax-highlighting
            vscode-inferno-lsp-server;
        };

    in
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = nixpkgs.lib.systems.flakeExposed;
      imports = [
        flake-parts.flakeModules.easyOverlay
        treefmt-nix.flakeModule
      ];
      # Outputs that are enumerated by system
      perSystem = { config, pkgs, lib, system, ... }:
        let
          flakes = flakesFor pkgs;
        in
        rec {
          # Set the `pkgs` that are passed to `perSystem`
          _module.args.pkgs = import nixpkgs {
            inherit (haskell-nix) config;
            inherit system;
            overlays = [
              haskell-nix.overlays.combined
              inputs.npm-buildpackage.overlays.default
            ];
          };

          # To enter a development environment for a particular GHC version, use
          # the compiler name, e.g. `nix develop .#ghc8107`
          #
          # Both of the `vscode-inferno` packages have `devShells` of the same
          # name, containing `nodejs` and NPM dependencies
          devShells =
            let
              mkNodeDevShell = pkg:
                let
                  # We can grab the `nodeModules` from the existing packages
                  # using the `passthru`s from `buildNpmPackage` and reuse them
                  # in the `devShell` corresponding to that package
                  inherit (self.packages.${system}.${pkg}.passthru) nodeModules;
                in
                pkgs.mkShell {
                  packages = [ pkgs.nodejs ];
                  shellHook = ''
                    export NODE_PATH=${nodeModules}/node_modules
                    # This is an executable so it should be added to the `PATH`
                    export PATH=$PATH:$NODE_PATH/@vscode/vsce
                    # Preventing `npm i` from creating a local `node_modules`
                    # ensures that we will always have a single, consistent set
                    # of NPM dependencies
                    export NPM_CONFIG_PACKAGE_LOCK_ONLY=true
                  '';
                };
            in
            lib.attrsets.mapAttrs'
              # FIXME
              # `ghc884` is broken, see https://github.com/plow-technologies/inferno/issues/23
              (compiler: v: lib.attrsets.nameValuePair compiler v.devShell)
              flakes
            // {
              default = flakes.${defaultCompiler}.devShell;
              vscode-inferno-lsp-server = mkNodeDevShell "vscode-inferno-lsp-server";
              vscode-inferno-syntax-highlighting = mkNodeDevShell "vscode-inferno-syntax-highlighting";
            };

          packages =
            let
              inherit (flakes.${defaultCompiler}) packages;
              # All of the packages for each compiler version, plus the VSCode
              # packages
              ps =
                collectOutputs "packages" flakes // {
                  inherit (vsCodeInfernoFor pkgs)
                    vscode-inferno-syntax-highlighting
                    vscode-inferno-lsp-server;
                  inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
                };
            in
            ps // {
              # Build all `packages`, `checks`, and `devShells`
              default = pkgs.runCommand "everything"
                {
                  combined = builtins.concatLists
                    [
                      (builtins.attrValues self.checks.${system})
                      (builtins.attrValues ps)
                      (
                        lib.mapAttrsToList
                          (_: v: v.inputDerivation)
                          (
                            # See https://github.com/plow-technologies/inferno/issues/23
                            builtins.removeAttrs self.devShells.${system} [ "ghc884" ]
                          )
                      )
                    ];
                }
                ''
                  echo $combined
                  touch $out
                '';
            };

          apps = collectOutputs "apps" flakes // {
            inferno-lsp-server =
              flakes.${defaultCompiler}.apps."inferno-lsp:exe:inferno-lsp-server";
          };

          # Usage: `nix build .#checks.<SYSTEM>.<check>`, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests`
          #
          # To run a check for a particular compiler version, suffix the derivation
          # name with the GHC version, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests-ghc924`
          checks =
            flakes.${defaultCompiler}.checks // collectOutputs "checks" flakes;

          formatter = treefmt-nix.lib.mkWrapper pkgs treefmt.config;

          # Defined packages included in the generated `overlays.default`
          overlayAttrs = {
            inherit (config.packages)
              inferno-lsp-server vscode-inferno-syntax-highlighting vscode-inferno-lsp-server;
          };

          # NOTE
          # This will generate a formatting check and can be reused in the
          # `formatter` output above
          treefmt.config = {
            projectRootFile = "flake.nix";
            programs = {
              nixpkgs-fmt.enable = true;
              ormolu = {
                enable = true;
                package = ormoluFor defaultCompiler pkgs;
                ghcOpts = [ "TypeApplications" ];
              };
            };
          };
        };
    };
}
