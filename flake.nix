{
  description = "inferno";

  nixConfig = {
    # These are required to build the project, otherwise GHC will be built from
    # source (this is not always possible using haskell.nix either), so it makes
    # sense to enable them directly in the flake
    extra-substituters = [
      "https://cache.iog.io"
      "https://inferno.cachix.org"
    ];
    extra-trusted-public-keys = [
      "hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ="
      "inferno.cachix.org-1:48GsOmEfRPXpTZsQSmnD2P42lpbUeHrjlzyhasL5rug="
    ];
    bash-prompt = "\\[\\e[0;37m\\](\\[\\e[0m\\]nix) \\[\\e[0;1;91m\\]inferno \\[\\e[0m\\]\\w \\[\\e[0;1m\\]Î» \\[\\e[0m\\]";
  };

  inputs = {
    nixpkgs.follows = "haskell-nix/nixpkgs-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    treefmt-nix.url = "github:numtide/treefmt-nix";
    # haskell.nix has far better support for multi-component projects, so it's
    # preferable over nixpkgs' Haskell support
    haskell-nix.url = "github:input-output-hk/haskell.nix";
    npm-buildpackage.url = "github:serokell/nix-npm-buildpackage";
    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };

    # Needed for the `hasktorch` integration
    hasktorch = {
      url = "github:hasktorch/hasktorch";
      # NOTE: `hasktorch` does have its own flake, but none of its outputs are
      # useful to us. We just need the source for `libtorch`
      flake = false;
    };
    tokenizers = {
      url = "github:hasktorch/tokenizers/flakes";
    };
  };

  outputs =
    { self
    , nixpkgs
    , flake-parts
    , treefmt-nix
    , haskell-nix
    , ...
    }@inputs:
    let
      inherit (nixpkgs) lib;

      defaultCompiler = "ghc924";

      # Takes an attribute set mapping compiler versions to `flake`s generated
      # by `haskell.nix` and suffixes each derivation in all flake outputs
      # selected by `attr` with the corresponding compiler version, then flattens
      # the resulting structure to combine all derivations into a single set
      #
      #    collectOutputs
      #      "checks"
      #      {
      #        ghc8107 = { checks = { x:y:z = <drv>; }; };
      #        ghc922 = { checks = { x:y:z = <drv>; }; };
      #      }
      #
      # => { x:y:z-ghc8107 = <drv>; x:y:z-ghc922 = <drv>; }
      collectOutputs = attr: flakes:
        let
          outputsByCompiler = lib.mapAttrsToList
            (compiler: flake: { "${compiler}" = flake.${attr} or { }; })
            flakes;
          addSuffix = compiler: lib.mapAttrs'
            (output: drv: lib.attrsets.nameValuePair "${output}-${compiler}" drv);
          withSuffixes = builtins.map
            (builtins.mapAttrs addSuffix)
            outputsByCompiler;
          justOutputs = builtins.concatMap builtins.attrValues withSuffixes;
        in
        builtins.foldl' lib.mergeAttrs { } justOutputs;

    in
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = nixpkgs.lib.systems.flakeExposed;
      imports = [
        flake-parts.flakeModules.easyOverlay
        treefmt-nix.flakeModule
      ];
      # Outputs that are enumerated by system
      perSystem = { config, pkgs, lib, system, ... }:
        let
          # Get the autogenerated flake outputs from `haskell.nix`, for different
          # GHC versions, with or without profiling enabled
          flakes = {
            "${defaultCompiler}-prof" = (
              infernoFor {
                profiling = true;
                ghcOptions = [ "-eventlog" ];
              }
            ).flake { };
            "${defaultCompiler}-cuda" = (
              infernoFor { torchConfig.device = "cuda-11"; }
            ).flake { };
          }
          // builtins.listToAttrs
            (
              lib.lists.forEach
                (
                  [ defaultCompiler ]
                    # only GHC 8.10.7 or newer is supported on M1 Macs
                    ++ lib.optional (pkgs.system != "aarch64-darwin") "ghc884"
                )
                (compiler:
                  lib.attrsets.nameValuePair
                    compiler
                    # TODO
                    # Do we want to enable any `crossPlatforms` here?
                    ((infernoFor { inherit compiler; }).flake { })
                )
            );

          # This should be parameterized by the `pkgs` used to build the project. We
          # want users who get packages from our `overlays.default` to be able to
          # use their own `nixpkgs` without having to instantiate ours as well
          # (which would happen if we just use `self.packages` directly in the overlay)
          infernoFor = args: import ./nix ({ inherit pkgs config inputs; } // args);

          # Inferno's VSCode packages
          vsCodeInferno =
            let
              modules = vscode-inferno-syntax-highlighting.passthru.nodeModules;
              vscode-inferno-syntax-highlighting =
                pkgs.buildNpmPackage {
                  src = ./vscode-inferno-syntax-highlighting;
                  npmBuild = ''
                    npm run build-tm
                    ${modules}/node_modules/@vscode/vsce/vsce package
                    npm run build-monarch
                  '';
                  installPhase = ''
                    mkdir $out
                    cp *.vsix $out
                    cp syntaxes/inferno.monarch.json $out
                  '';
                };
              vscode-inferno-lsp-server = pkgs.buildNpmPackage {
                src = ./vscode-inferno-lsp-server;
                nativeBuildInputs = [ pkgs.nodePackages.typescript ];
                npmBuild = ''
                  npm run package
                '';
                installPhase = "mkdir $out && cp *.vsix $out";
              };
            in
            {
              inherit
                vscode-inferno-syntax-highlighting vscode-inferno-lsp-server;
            };

        in
        rec {
          # Set the `pkgs` that are passed to `perSystem`
          _module.args.pkgs = import nixpkgs {
            inherit (haskell-nix) config;
            inherit system;
            overlays = [ self.overlays.combined ];
          };

          legacyPackages = pkgs // infernoFor { compiler = defaultCompiler; };

          # To enter a development environment for a particular GHC version, use
          # the compiler name, e.g. `nix develop .#ghc8107`
          #
          # Both of the `vscode-inferno` packages have `devShells` of the same
          # name, containing `nodejs` and NPM dependencies
          devShells =
            let
              mkNodeDevShell = pkg:
                let
                  # We can grab the `nodeModules` from the existing packages
                  # using the `passthru`s from `buildNpmPackage` and reuse them
                  # in the `devShell` corresponding to that package
                  inherit (self.packages.${system}.${pkg}.passthru) nodeModules;
                in
                pkgs.mkShell {
                  packages = [ pkgs.nodejs ];
                  shellHook = ''
                    export NODE_PATH=${nodeModules}/node_modules
                    # This is an executable so it should be added to the `PATH`
                    export PATH=$PATH:$NODE_PATH/@vscode/vsce
                    # Preventing `npm i` from creating a local `node_modules`
                    # ensures that we will always have a single, consistent set
                    # of NPM dependencies
                    export NPM_CONFIG_PACKAGE_LOCK_ONLY=true
                  '';
                };
            in
            builtins.mapAttrs (_: v: v.devShell) flakes
            // {
              default = flakes.${defaultCompiler}.devShell;
              vscode-inferno-lsp-server = mkNodeDevShell "vscode-inferno-lsp-server";
              vscode-inferno-syntax-highlighting = mkNodeDevShell "vscode-inferno-syntax-highlighting";
              pytorch =
                pkgs.mkShell {
                  packages = [
                    (
                      pkgs.python3.withPackages (
                        ps: with ps; [ torch torchvision ]
                      )
                    )
                  ];
                };
            };

          packages =
            let
              inherit (flakes.${defaultCompiler}) packages;
              # All of the packages for each compiler version, plus the VSCode
              # packages
              ps =
                collectOutputs "packages" flakes // {
                  inherit (vsCodeInferno)
                    vscode-inferno-syntax-highlighting vscode-inferno-lsp-server;
                  inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
                };
              inferno = "inferno-core:exe:inferno";
              inferno-ml = "inferno-ml:exe:inferno-ml-exe";
              vscode-inferno = pkgs.runCommand "vscode-inferno"
                { }
                ''
                  mkdir -p $out/{vscode,bin}
                  ln -s ${ps.vscode-inferno-syntax-highlighting} $out/vscode/syntax-highlighting
                  ln -s ${ps.vscode-inferno-lsp-server} $out/vscode/lsp-server
                  ln -s ${ps.inferno-lsp-server} $out/bin/inferno-lsp-server
                '';
            in
            ps // {
              inherit vscode-inferno;
              inferno = packages.${inferno};
              inferno-ml = packages.${inferno-ml};
              inferno-ml-cpu = packages.${inferno-ml};
              inferno-ml-cuda = flakes."${defaultCompiler}-cuda".packages.${inferno-ml};
              # Build all `packages`, `checks`, and `devShells`
              default = pkgs.runCommand "almost-everything"
                {
                  combined =
                    builtins.concatLists [
                      [
                        self.checks.${system}.treefmt
                        flakes.${defaultCompiler}.devShell
                      ]
                      (builtins.attrValues flakes.${defaultCompiler}.checks)
                      (
                        builtins.attrValues (
                          packages // { inherit vscode-inferno; }
                        )
                      )
                    ];
                }
                ''
                  echo $combined
                  touch $out
                '';
            };

          apps = collectOutputs "apps" flakes // {
            inferno-lsp-server =
              flakes.${defaultCompiler}.apps."inferno-lsp:exe:inferno-lsp-server";
          };

          # Usage: `nix build .#checks.<SYSTEM>.<check>`, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests`
          #
          # To run a check for a particular compiler version, suffix the derivation
          # name with the GHC version, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests-ghc924`
          checks =
            flakes.${defaultCompiler}.checks // collectOutputs "checks" flakes;

          formatter = treefmt-nix.lib.mkWrapper pkgs treefmt.config;

          # Defined packages included in the generated `overlays.default`
          overlayAttrs = {
            inherit (config.packages)
              inferno-lsp-server vscode-inferno-syntax-highlighting vscode-inferno-lsp-server;
          };

          # NOTE
          # This will generate a formatting check and can be reused in the
          # `formatter` output above. We can also use the `programs` attribute
          # to easily get all of the formatters in one place (e.g. in the
          # `devShells`)
          treefmt.config = {
            projectRootFile = "flake.nix";
            programs = { nixpkgs-fmt.enable = true; }
              # FIXME
              # Ormolu segfaults on `aarch64-darwin` so it should be disabled
              # everywhere (i.e. just omit it from `treefmt.config`).
              #
              # See https://github.com/plow-technologies/inferno/issues/10
              // lib.optionalAttrs (system != "aarch64-darwin")
              {
                ormolu = {
                  enable = true;
                  package =
                    let
                      # Using `hackage-package` will prevent building `ormolu`
                      # from interfering with the build plan (incl. incompatible
                      # compiler versions)
                      o = pkgs.haskell-nix.hackage-package {
                        name = "ormolu";
                        version = "0.5.0.1";
                        compiler-nix-name = defaultCompiler;
                        configureArgs = "--disable-benchmarks --disable-tests";
                      };
                    in
                    o.getComponent "exe:ormolu";
                  ghcOpts = [ "TypeApplications" ];
                };
              };
          };
        };

      flake.overlays = {
        combined = lib.composeManyExtensions [
          haskell-nix.overlays.combined
          inputs.npm-buildpackage.overlays.default
          inputs.tokenizers.overlay
          (_:_: { inherit (inputs) hasktorch; })
          (import ./nix/overlays/compat.nix)
          (import ./nix/overlays/torch.nix)
        ];
      };
    };
}
