{
  description = "inferno";

  nixConfig = {
    # These are required to build the project, otherwise GHC will be built from
    # source (this is not always possible using haskell.nix either), so it makes
    # sense to enable them directly in the flake
    extra-substituters = [ "https://cache.iog.io" ];
    extra-trusted-public-keys = [
      "hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ="
    ];
    bash-prompt = "\\[\\e[0;37m\\](\\[\\e[0m\\]nix) \\[\\e[0;1;91m\\]inferno \\[\\e[0m\\]\\w \\[\\e[0;1m\\]Î» \\[\\e[0m\\]";
  };

  inputs = {
    nixpkgs.follows = "haskell-nix/nixpkgs-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    treefmt.url = "github:numtide/treefmt";
    # haskell.nix has far better support for multi-component projects, so it's
    # preferable over nixpkgs' Haskell support
    haskell-nix.url = "github:input-output-hk/haskell.nix";
    npm-buildpackage.url = "github:serokell/nix-npm-buildpackage";
    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };
  };

  outputs =
    { self
    , nixpkgs
    , flake-parts
    , treefmt
    , haskell-nix
    , ...
    }@inputs:
    let
      inherit (nixpkgs) lib;

      defaultCompiler = "ghc924";

      # Takes an attribute set mapping compiler versions to `flake`s generated
      # by `haskell.nix` (see `flakesFor` above) and suffixes each derivation
      # in all flake outputs selected by `attr` with the corresponding compiler
      # version, then flattens the resulting structure to combine all derivations
      # into a single set
      #
      #    collectOutputs
      #      "checks"
      #      {
      #        ghc8107 = { checks = { x:y:z = <drv>; }; };
      #        ghc922 = { checks = { x:y:z = <drv>; }; };
      #      }
      #
      # => { x:y:z-ghc8107 = <drv>; x:y:z-ghc922 = <drv>; }
      collectOutputs = attr: flakes:
        let
          outputsByCompiler = lib.mapAttrsToList
            (compiler: flake: { "${compiler}" = flake.${attr} or { }; })
            flakes;
          addSuffix = compiler: lib.attrsets.mapAttrs'
            (output: drv:
              lib.attrsets.nameValuePair "${output}-${compiler}" drv
            );
          withSuffixes = builtins.map
            (builtins.mapAttrs addSuffix)
            outputsByCompiler;
          justOutputs = builtins.concatMap builtins.attrValues withSuffixes;
        in
        builtins.foldl' (x: y: x // y) { } justOutputs;

      # Everything related to the haskell.nix project needs to be defined here
      # in order to be used by both the system-enumerated outputs (`packages`,
      # `devShells`, etc, ...) and the non-enumerated ones (`overlays`, etc...).
      # This also means that everything needs to be parameterized by `pkgs`

      # Get the autogenerated flake outputs from `haskell.nix`, for different
      # GHC versions
      flakesFor = pkgs: builtins.listToAttrs
        (
          # only GHC 8.10.7 or newer is supported on M1 Macs
          lib.lists.forEach
            (
              [ defaultCompiler ]
              ++ lib.optional (pkgs.system != "aarch64-darwin") "ghc884"
            )
            (compiler: lib.attrsets.nameValuePair
              compiler
              # TODO
              # Do we want to enable any `crossPlatforms` here?
              ((infernoFor compiler pkgs { }).flake { })
            ) ++
          lib.lists.forEach [ defaultCompiler ]
            (compiler: lib.attrsets.nameValuePair
              (compiler + "-prof")
              ((infernoFor compiler pkgs { profiling = true; ghcOptions = [ "-eventlog" ]; }).flake { })
            )
        );

      # This should be parameterized by the `pkgs` used to build the project. We
      # want users who get packages from our `overlays.default` to be able to
      # use their own `nixpkgs` without having to instantiate ours as well
      # (which would happen if we just use `self.packages` directly in the overlay)
      infernoFor = compiler: pkgs: { ghcOptions ? [ ], profiling ? false }: pkgs.haskell-nix.cabalProject {
        name = "inferno";
        compiler-nix-name = compiler;
        src = builtins.path {
          path = ./.;
          filter = path: type:
            builtins.any
              (ext: baseNameOf path != ext)
              [ ".nix" ".md" ];
        };
        shell = {
          withHoogle = true;
          tools = {
            cabal = { };
            haskell-language-server = { };
          };
          buildInputs = [ pkgs.nixpkgs-fmt ] ++
            # ormolu build currently segfaults on the M1
            lib.optional (pkgs.system != "aarch64-darwin") (ormoluFor compiler pkgs);
        };
        modules = [
          {
            enableLibraryProfiling = profiling;
            packages = {
              # This takes forever to build
              ghc.components.library.doHaddock = false;
            };
            packages.inferno-core = {
              enableLibraryProfiling = profiling;
              enableProfiling = profiling;
              inherit ghcOptions;
            };
          }
        ];
      };

      # Get the same version of `ormolu` everywhere, including the shell
      ormoluFor = compiler: pkgs: pkgs.haskell-nix.tool
        compiler "ormolu" "0.5.0.1";

      # Inferno's VSCode packages
      vsCodeInfernoFor = pkgs:
        let
          modules = vscode-inferno-syntax-highlighting.passthru.nodeModules;
          vscode-inferno-syntax-highlighting =
            pkgs.buildNpmPackage {
              src = ./vscode-inferno-syntax-highlighting;
              npmBuild = ''
                npm run build-tm
                ${modules}/node_modules/@vscode/vsce/vsce package
                npm run build-monarch
              '';
              installPhase = ''
                mkdir $out
                cp *.vsix $out
                cp syntaxes/inferno.monarch.json $out
              '';
            };
          vscode-inferno-lsp-server = pkgs.buildNpmPackage {
            src = ./vscode-inferno-lsp-server;
            nativeBuildInputs = [ pkgs.nodePackages.typescript ];
            npmBuild = ''
              npm run package
            '';
            installPhase = "mkdir $out && cp *.vsix $out";
          };
        in
        {
          inherit
            vscode-inferno-syntax-highlighting
            vscode-inferno-lsp-server;
        };

    in
    flake-parts.lib.mkFlake { inherit self; } {
      systems = nixpkgs.lib.systems.flakeExposed;
      # Outputs that are enumerated by system
      perSystem = { config, pkgs, lib, system, ... }:
        let
          flakes = flakesFor pkgs;
        in
        {
          # Set the `pkgs` that are passed to `perSystem`
          _module.args.pkgs = import nixpkgs {
            inherit (haskell-nix) config;
            inherit system;
            overlays = [
              haskell-nix.overlays.combined
              inputs.npm-buildpackage.overlays.default
            ];
          };

          # To enter a development environment for a particular GHC version, use
          # the compiler name, e.g. `nix develop .#ghc8107`
          #
          # Both of the `vscode-inferno` packages have `devShells` of the same
          # name, containing `nodejs` and NPM dependencies
          devShells =
            let
              mkNodeDevShell = pkg:
                let
                  # We can grab the `nodeModules` from the existing packages
                  # using the `passthru`s from `buildNpmPackage` and reuse them
                  # in the `devShell` corresponding to that package
                  inherit (self.packages.${system}.${pkg}.passthru) nodeModules;
                in
                pkgs.mkShell {
                  packages = [ pkgs.nodejs ];
                  shellHook = ''
                    export NODE_PATH=${nodeModules}/node_modules
                    # This is an executable so it should be added to the `PATH`
                    export PATH=$PATH:$NODE_PATH/@vscode/vsce
                    # Preventing `npm i` from creating a local `node_modules`
                    # ensures that we will always have a single, consistent set
                    # of NPM dependencies
                    export NPM_CONFIG_PACKAGE_LOCK_ONLY=true
                  '';
                };
            in
            lib.attrsets.mapAttrs'
              (compiler: v: lib.attrsets.nameValuePair compiler v.devShell)
              flakes
            // {
              default = flakes.${defaultCompiler}.devShell;
              vscode-inferno-lsp-server = mkNodeDevShell "vscode-inferno-lsp-server";
              vscode-inferno-syntax-highlighting = mkNodeDevShell "vscode-inferno-syntax-highlighting";
            };

          packages =
            let
              inherit (flakes.${defaultCompiler}) packages;
              # All of the packages for each compiler version, plus the VSCode
              # packages
              ps =
                collectOutputs "packages" flakes // {
                  inherit (vsCodeInfernoFor pkgs)
                    vscode-inferno-syntax-highlighting
                    vscode-inferno-lsp-server;
                  inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
                };
            in
            ps // {
              # Build all packages and checks
              default = pkgs.runCommand "check"
                {
                  combined = builtins.attrValues self.checks.${system}
                  ++ builtins.attrValues ps;
                }
                ''
                  echo $combined
                  touch $out
                '';
            };

          apps =
            let
              inherit (flakes.${defaultCompiler}) apps;
            in
            {
              inferno-lsp-server = apps."inferno-lsp:exe:inferno-lsp-server";
            } // collectOutputs "apps" flakes;

          # Usage: `nix build .#checks.<SYSTEM>.<check>`, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests`
          #
          # To run a check for a particular compiler version, suffix the derivation
          # name with the GHC version, e.g.
          #
          # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests-ghc924`
          checks =
            {
              formatting = pkgs.runCommand "formatting-check"
                {
                  buildInputs = [ pkgs.nixpkgs-fmt (ormoluFor defaultCompiler pkgs) ];
                }
                ''
                  cp -r --no-preserve=mode --preserve=timestamps ${self}/* .
                  chmod -R +rwx .
                  export HOME=$TMPDIR
                  ${treefmt.legacyPackages.${system}.treefmt}/bin/treefmt --fail-on-change
                  touch $out
                '';
            }
            // flakes.${defaultCompiler}.checks
            // collectOutputs "checks" flakes;

          # NOTE
          # This should be run from the development shell (i.e. run `nix develop` first).
          # Treefmt expects the formatters to be on the PATH
          formatter = treefmt.legacyPackages.${system}.withConfig {
            settings = lib.importTOML ./treefmt.toml;
            projectRootFile = "flake.nix";
          };
        };

      # Non-enumerated outputs
      flake = {
        overlays.default = lib.composeManyExtensions [
          (final: prev:
            # Needed to build the VSCode packages
            lib.optionalAttrs (!(prev ? buildNpmPackage))
              (inputs.npm-buildpackage.overlays.default final prev)
            # Needed to build Inferno itself
            // lib.optionalAttrs (!(prev ? haskell-nix))
              (inputs.haskell-nix.overlays.combined final prev)
          )
          (_: prev:
            let
              inherit ((flakesFor prev).${defaultCompiler}) packages;
            in
            {
              inherit
                (vsCodeInfernoFor prev)
                vscode-inferno-syntax-highlighting
                vscode-inferno-lsp-server;
              inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
            }
          )
        ];
      };
    };
}
