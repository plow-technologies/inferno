{
  description = "inferno";

  nixConfig = {
    # These are required to build the project, otherwise GHC will be built from
    # source (this is not always possible using haskell.nix either), so it makes
    # sense to enable them directly in the flake
    extra-substituters = [ "https://cache.iog.io" ];
    extra-trusted-public-keys = [
      "hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ="
    ];
    bash-prompt = "\\[\\e[0;37m\\](nix) \\[\\e[0;1;91m\\]inferno\\[\\e[0m\\] Î» ";
  };

  inputs = {
    nixpkgs.follows = "haskell-nix/nixpkgs-unstable";
    treefmt.url = "github:numtide/treefmt";
    # haskell.nix has far better support for multi-component projects, so it's
    # preferable over nixpkgs' Haskell support
    haskell-nix.url = "github:input-output-hk/haskell.nix";
    npm-buildpackage.url = "github:serokell/nix-npm-buildpackage";
    vscode-vsce = {
      url = "github:microsoft/vscode-vsce/20378752b7931016bd43886184d623b157703639";
      flake = false;
    };
    flake-compat = {
      url = "github:edolstra/flake-compat";
      flake = false;
    };
  };

  outputs = { self, nixpkgs, haskell-nix, treefmt, ... }@inputs:
    let
      inherit (nixpkgs) lib;
      # some boilerplate, `flake-utils` doesn't work well with `haskell.nix` due
      # to widespread use of IFD in the latter
      perSystem = lib.genAttrs nixpkgs.lib.systems.flakeExposed;
      nixpkgsForSystem = system: import nixpkgs {
        inherit (haskell-nix) config;
        inherit system;
        overlays = [
          haskell-nix.overlays.combined
          inputs.npm-buildpackage.overlays.default
        ];
      };
      allNixpkgsFor = perSystem nixpkgsForSystem;
      nixpkgsFor = system: allNixpkgsFor.${system};

      infernoFor = compiler: pkgs: pkgs.haskell-nix.cabalProject {
        name = "inferno";
        # TODO
        # Perhaps we can support multiple compiler versions
        # We should probably build with GHC 9.2.x at any rate
        compiler-nix-name = compiler;
        src = builtins.path {
          path = ./.;
          filter = path: type:
            builtins.any
              (ext: baseNameOf path != ext)
              [ ".nix" ".md" ];
        };
        shell = {
          withHoogle = true;
          tools = {
            cabal = { };
            haskell-language-server = { };
          };
          buildInputs = with nixpkgs.legacyPackages.${pkgs.system}; [
            nixpkgs-fmt
            (ormoluFor compiler pkgs)
          ];
        };
        modules = [
          {
            packages = {
              # This takes forever to build
              ghc.components.library.doHaddock = false;
            };
          }
        ];
      };

      # Get the same version of `ormolu` everywhere, including the shell
      ormoluFor = compiler: pkgs: pkgs.haskell-nix.tool
        compiler "ormolu" "0.5.0.1";

      # Inferno's VSCode packages
      vsCodeInfernoFor = pkgs:
        let
          vsce = pkgs.buildYarnPackage {
            src = inputs.vscode-vsce;
            yarnBuild = ''
              yarn
              yarn run compile
            '';
            installPhase = ''
              cp -Lr . $out
              mkdir $out/bin
              ln -s $out/out/vsce $out/bin/vsce
            '';
          };
        in
        {
          vscode-inferno-syntax-highlighting = pkgs.buildNpmPackage {
            src = ./vscode-inferno-syntax-highlighting;
            nativeBuildInputs = [ vsce ];
            npmBuild = ''
              npm run build-tm
              vsce package
              npm run build-monarch
            '';
            installPhase = ''
              mkdir $out
              cp *.vsix $out
              cp syntaxes/inferno.monarch.json $out
            '';
          };
          vscode-inferno-lsp-server = pkgs.buildNpmPackage {
            src = ./vscode-inferno-lsp-server;
            nativeBuildInputs = [ vsce pkgs.nodePackages.typescript ];
            npmBuild = ''
              npm run package
            '';
            installPhase = "mkdir $out && cp *.vsix $out";
          };
        };

      defaultCompiler = "ghc924";

      # Get the autogenerated flake outputs from `haskell.nix`, for different
      # GHC versions
      flakesFor = pkgs: builtins.listToAttrs
        (
          lib.lists.forEach [ defaultCompiler "ghc884" ]
            (compiler: lib.attrsets.nameValuePair
              compiler
              # TODO
              # Do we want to enable any `crossPlatforms` here?
              ((infernoFor compiler pkgs).flake { })
            )
        );

      # Takes an attribute set mapping compiler versions to `flake`s generated
      # by `haskell.nix` (see `flakesFor` above) and suffixes each derivation
      # in all flake outputs selected by `attr` with the corresponding compiler
      # version, then flattens the resulting structure to combine all derivations
      # into a single set
      #
      #    collectOutputs
      #      "checks"
      #      {
      #        ghc8107 = { checks = { x:y:z = <drv>; }; };
      #        ghc922 = { checks = { x:y:z = <drv>; }; };
      #      }
      #
      # => { x:y:z-ghc8107 = <drv>; x:y:z-ghc922 = <drv>; }
      collectOutputs = attr: flakes:
        let
          outputsByCompiler = lib.mapAttrsToList
            (compiler: flake: { "${compiler}" = flake.${attr} or { }; })
            flakes;
          addSuffix = compiler: lib.attrsets.mapAttrs'
            (output: drv:
              lib.attrsets.nameValuePair "${output}-${compiler}" drv
            );
          withSuffixes = builtins.map
            (builtins.mapAttrs addSuffix)
            outputsByCompiler;
          justOutputs = builtins.concatMap builtins.attrValues withSuffixes;
        in
        builtins.foldl' (x: y: x // y) { } justOutputs;

    in
    {
      packages = perSystem (system:
        let
          inherit (flakes.${defaultCompiler}) packages;
          flakes = flakesFor pkgs;
          pkgs = nixpkgsFor system;
          # All of the packages for each compiler version, plus the VSCode
          # packages
          ps =
            collectOutputs "packages" flakes // {
              inherit (vsCodeInfernoFor pkgs)
                vscode-inferno-syntax-highlighting
                vscode-inferno-lsp-server;
              inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
            };
        in
        ps // {
          # Build all packages and checks
          default = pkgs.runCommand "check"
            {
              combined = builtins.attrValues self.checks.${system}
              ++ builtins.attrValues ps;
            }
            ''
              echo $combined
              touch $out
            '';
        }
      );

      apps = perSystem (system:
        let
          inherit (flakes.${defaultCompiler}) apps;
          flakes = flakesFor (nixpkgsFor system);
        in
        {
          inferno-lsp-server = apps."inferno-lsp:exe:inferno-lsp-server";
        } // collectOutputs "apps" flakes
      );

      # To enter a development environment for a particular GHC version, use
      # the compiler name, e.g. `nix develop .#ghc8107`
      devShells = perSystem (system:
        let
          flakes = flakesFor (nixpkgsFor system);
        in
        {
          default = flakes.${defaultCompiler}.devShell;
        } // lib.attrsets.mapAttrs'
          (compiler: v: lib.attrsets.nameValuePair compiler v.devShell)
          flakes
      );

      # Usage: `nix build .#checks.<SYSTEM>.<check>`, e.g.
      #
      # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests`
      #
      # To run a check for a particular compiler version, suffix the derivation
      # name with the GHC version, e.g.
      #
      # `nix build .#checks.x86_64-linux.inferno-core:test:inferno-tests-${defaultCompiler}`
      checks = perSystem (system:
        let
          pkgs = nixpkgsFor system;
          flakes = flakesFor pkgs;
        in
        {
          formatting = pkgs.runCommand "formatting-check"
            {
              buildInputs = [ pkgs.nixpkgs-fmt (ormoluFor defaultCompiler pkgs) ];
            }
            ''
              set -euo pipefail
              cp -r ${self}/* .
              chmod -R +rwx .
              ${treefmt.legacyPackages.${system}.treefmt}/bin/treefmt --fail-on-change
            '';
        }
        // flakes.${defaultCompiler}.checks
        // collectOutputs "checks" flakes
      );

      overlays.default = lib.composeManyExtensions [
        (final: prev:
          # Needed to build the VSCode packages
          lib.optionalAttrs (!(prev ? buildNpmPackage))
            (inputs.npm-buildpackage.overlays.default final prev)
          # Needed to build Inferno itself
          // lib.optionalAttrs (!(prev ? haskell-nix))
            (inputs.haskell-nix.overlays.combined final prev)
        )
        (_: prev:
          let
            inherit ((flakesFor prev).${defaultCompiler}) packages;
          in
          {
            inherit
              (vsCodeInfernoFor prev)
              vscode-inferno-syntax-highlighting
              vscode-inferno-lsp-server;
            inferno-lsp-server = packages."inferno-lsp:exe:inferno-lsp-server";
          }
        )
      ];

      # NOTE
      # This should be run from the development shell (i.e. run `nix develop` first).
      # Treefmt expects the formatters to be on the PATH
      formatter = perSystem (system:
        treefmt.legacyPackages.${system}.withConfig {
          settings = nixpkgs.lib.importTOML ./treefmt.toml;
          projectRootFile = "flake.nix";
        }
      );
    };
}
